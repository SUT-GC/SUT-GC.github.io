I"b<ul class="toc" id="markdown-toc">
  <li><a href="#heading-聊聊超卖" id="markdown-toc-heading-聊聊超卖">聊聊超卖</a>    <ul>
      <li><a href="#heading-电商交易流程" id="markdown-toc-heading-电商交易流程">电商交易流程</a></li>
      <li><a href="#heading-超卖是什么" id="markdown-toc-heading-超卖是什么">超卖是什么</a></li>
      <li><a href="#heading-为什么会有超卖" id="markdown-toc-heading-为什么会有超卖">为什么会有超卖</a>        <ul>
          <li><a href="#heading-业务超卖" id="markdown-toc-heading-业务超卖">业务超卖</a></li>
          <li><a href="#heading-技术超卖" id="markdown-toc-heading-技术超卖">技术超卖</a></li>
        </ul>
      </li>
      <li><a href="#heading-总结" id="markdown-toc-heading-总结">总结</a></li>
    </ul>
  </li>
</ul>

<h1 id="heading-聊聊超卖">聊聊超卖</h1>

<p><strong>焦点：</strong> 这篇文章，主要是想聊一聊 “超卖” 这个场景，并且借此，串一下整个电商的交易流程，加深对电商交易的认真。</p>

<h2 id="heading-电商交易流程">电商交易流程</h2>
<p>我们先看下电商的交易流程：</p>

<p><img src="http://int32-blog.oss-cn-beijing.aliyuncs.com/%E4%BA%A4%E6%98%93%E9%93%BE%E8%B7%AF%E6%A0%91%E7%AB%8B.png" alt="image" /></p>

<p>不管是同城外卖场景，还是异城的的传统电商购物，主要流程都不会有太多区别。</p>

<ul>
  <li>商品筛选</li>
</ul>

<p>交易的实体是商品，而商品筛选是最先经历的一环，用户的目的是从无数的商品中，筛选（搜索）出自己想要买的那一款，所以搜索这一环是平台必须提供的能力，而平台的目的，就是在无数的商品中，尽可能的将用户要买的商品摆到用户面前，这也就是所谓的 “推荐“</p>

<p>根据业务场景不同，外卖电商会有很强的商家概念，所谓“很强”，就是会在用户端凸显商家的存在，用户第一选择的主体是商铺，然后才是商铺中的商品。而普通电商并不是没有商家，而是商家不会在用户端被很强的凸显出来。</p>

<ul>
  <li>商品详情</li>
</ul>

<p>对交易实体-商品的详细介绍，包括商品图片，商品介绍，商品价格等等，目的是让用户能够对商品本身有个更清晰的认知，一些特殊的技术如：全景，模拟，视频，等都在努力丰富用户对产品的认知。</p>

<ul>
  <li>购买确认</li>
</ul>

<p>用户选好商品后准备购买的二次确认操作，无论是选一件商品，还是选多件商品，都需要用户确认，本质上来说，买一件商品和买多件商品并没有区别，但在存储上，根据业务场景不同，会有不同的实现手段，比如外卖电商是只能在一个店铺下进行多商品购买的（方便后面配送履约），普通电商是可以跨店购买商品的（后面的逻辑是拆单，将不同店铺的商品，拆成不同单）。二次确认主要是让用户再次明确：商品价格、优惠政策、配送地址等，也叫预签合同，当用户对此合同支付完成之后，合同便开始生效（创建订单，订单状态开始流转），直到商品配送到用户手里，用户满意后确认收货，合同完成（订单完结）</p>

<ul>
  <li>支付货币</li>
</ul>

<p>有自主钱包的，可以免跳转第三方支付，没有自主钱包的平台，都会跳转三方支付平台进行支付，用户确认付款后。</p>

<ul>
  <li>商品履约</li>
</ul>

<p>商品配送可以分为本地生活类的骑手配送（商家送，自取等），和快递类的全国送（得益于国家强大，基建完善：中国邮政无处不在），履约也有可能有自身的状态流转（比如待接单，接单送出，商品送达等），所以仔细一点的电商 平台都会有区别于“用户单”的“履约单”，履约单又是一大堆的细节，这里不做细节讨论。</p>

<h2 id="heading-超卖是什么">超卖是什么</h2>

<p>超卖本身是一个股票概念，不知道为什么出现在电商交易中，而在电商交易中，超卖指：卖出商品的数量 大于 商品可卖库存。</p>

<p>还原真实场景，看下什么时候，卖出的商品数量 大于 商品可卖库存。打个比方 A是商户，手里有10个苹果，每个1块钱；B、C、D是买家，都要买苹果，不过B、C、D的需求各不相同，用表格来具体一下数据。</p>

<table>
  <tbody>
    <tr>
      <td>人</td>
      <td>类型</td>
      <td>动作</td>
      <td>苹果数量</td>
    </tr>
    <tr>
      <td>:—:</td>
      <td>:—:</td>
      <td>:—:</td>
      <td>:—:</td>
    </tr>
    <tr>
      <td>A</td>
      <td>商户</td>
      <td>出售</td>
      <td>10</td>
    </tr>
    <tr>
      <td>B</td>
      <td>用户</td>
      <td>购买</td>
      <td>5</td>
    </tr>
    <tr>
      <td>C</td>
      <td>用户</td>
      <td>购买</td>
      <td>4</td>
    </tr>
    <tr>
      <td>D</td>
      <td>用户</td>
      <td>购买</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p>在看几种有意思的交易流程：</p>

<p>场景（一） 顺序交易，先付款，后交货，无逆向</p>
<ul>
  <li>B准备买5个苹果，然后把5块钱给了A，A收了钱后发现自己还有10个苹果，就把其中5个给了B，B交易完成</li>
  <li>C准备买4个苹果，然后把4块钱给了A，A收了钱后发现自己还有5个苹果，就把其中4个给了C，C交易完成</li>
  <li>D准备买2个苹果，然后把2块钱给了A，A收了钱后发现自己还有1个苹果，就把钱还给了A，说库存不够了，A交易停止</li>
  <li>A剩余1个苹果</li>
</ul>

<p>场景（二）顺序交易，先交货，后付款，无逆向</p>
<ul>
  <li>B准备买5个苹果，A发现自己有10个苹果，就拿出5个给了B，B给了A 5块钱，B交易完成</li>
  <li>C准备买4个苹果，A发现自己有5个苹果，就拿出4个给了C，C给了A 4块钱，C交易完成</li>
  <li>D准备买2个苹果，A发现自己有1个苹果，就说库存不够，B交易停止</li>
  <li>A剩余1个苹果</li>
</ul>

<p>场景（三）顺序交易，先交货，后付款，有逆向</p>
<ul>
  <li>B准备买5个苹果，A发现自己有10个苹果，就拿出5个给了B，B给了A 5块钱，B交易完成</li>
  <li>C准备买4个苹果，A发现自己有5个苹果，就拿出4个给了C，C不想付款了，就把4个苹果还给了A，C交易停止</li>
  <li>D准备买2个苹果，A发现自己有5个苹果，就拿出2个给了D，D给了A 2块钱，D交易完成</li>
  <li>A剩余3个苹果</li>
</ul>

<p>场景（四）并发交易，先交货，后付款，有逆向</p>
<ul>
  <li>B准备买5个苹果，A发现自己有10个苹果，就拿出5个给了B，B给了A 5块钱，B交易完成</li>
  <li>C和D同时来买苹果，C要4个，D要2个，A先给C拿出4个，又准备给D拿出2个，发现库存不足，D交易停止，C不想付款了，C把4个苹果还给了A，C交易停止</li>
  <li>A剩余5个苹果</li>
</ul>

<p>所以，现实场景中，根本 <strong>不会发生</strong> 超卖， 由于业务是现实场景的反馈，所以，业务上也 <strong>不会发生</strong> 超卖</p>

<blockquote>
  <p>业务上不会发生超卖</p>
</blockquote>

<p>把准备交易比作“创建订单”，把A拿出苹果比作“扣减库存”，把B交钱给A比作“付款”， 那上面的场景可以简化为：</p>
<ul>
  <li>创建订单，支付成功，扣减库存（可简称 支付后扣库存）</li>
  <li>创建订单，扣减库存，支付成功（可简称 创单后扣库存）</li>
  <li>创建订单，扣减库存，支付取消，回滚库存</li>
</ul>

<h2 id="heading-为什么会有超卖">为什么会有超卖</h2>

<p>上面说了，业务上不会发生超卖，可大家一直谈论的“交易超卖”是什么呢？还是要分两个方面看：</p>
<ul>
  <li>业务超卖</li>
  <li>技术超卖</li>
</ul>

<h3 id="heading-业务超卖">业务超卖</h3>

<p>刚说了“业务上不会发生超卖”，为什么会有“业务超卖”呢？ 是因为一些公司，在正常的流程中，人为的改变了一些业务因素，才会导致。</p>

<p>举个例子，拼多多的电商场景，是以用户为主的，原则是大力维护用户利益，在发生交易的时候，如果用户付款之后，平台发现商品已经没有库存了，宁可想办法补调商品（可能会损失平台利益），争取让用户购买到，即特殊情况除外，不会主动发生退款现象（即不会发生场景一，D购买的情况）</p>

<p>那，根据拼多多电商场景，默认不主动退款，而支付后扣库存的场景，我们模拟一个超卖的逻辑：</p>

<p>场景（五）并发交易，先付款，后交货，不主动退款</p>
<ul>
  <li>B准备买5个苹果，然后把5块钱给了A，A收了钱后发现自己还有10个苹果，就把其中5个给了B，B交易完成</li>
  <li>C和D同时来买苹果，C给A 4块钱，要买4个，D给A 2块钱要买2个，A收了C和D的钱，A发现还剩5个苹果，就先给A了4个，然后A发现就剩1个了，不足以支付D 2个苹果，但是因为 <strong>不主动退款</strong> 的原则，只能想办法掉（或者自己从其他人那买）1个进来，然后再给D 2个苹果。对A来说，超卖了1个（计划卖10个，但是卖了11个）</li>
</ul>

<blockquote>
  <p>所谓的业务超卖，就是在正常交易场景下，因为一些业务原因，导致部分环节不执行，导致超卖       <br />
支付后扣库存， 不主动退款的情况下，会超卖       <br />
下单后扣库存，不主动拦截下单的情况下，会超卖          <br />
其中逻辑，耐人寻味</p>
</blockquote>

<h3 id="heading-技术超卖">技术超卖</h3>

<p>为了变量单一，我们假设业务流程正常，即无业务超卖，单从技术上来看，如何发生超卖？如何避免超卖？</p>

<p><img src="http://int32-blog.oss-cn-beijing.aliyuncs.com/Pasted%20Graphic%202.png" alt="image" />￼</p>

<p>把流程聚焦，在交易链路中，存在两种顺序的扣库存行为，一种是下单之后扣库存，一种是支付之后扣库存，由于这两种场景都属于业务场景，业务场景不发生超卖的前提下，只考虑技术导致超卖，那超卖只会发生在「扣减库存」这个点上。</p>

<p>把「扣减库存」这个点放大，可以看到最简单的扣库存架构，将扣库存流程做到最简化，时序图如下：</p>

<p><img src="http://int32-blog.oss-cn-beijing.aliyuncs.com/%E8%AE%A2%E5%8D%95%E7%89%88%E5%8A%A1%20%E4%BD%A0%E5%AD%98%20Server%20A.png" alt="image" /></p>

<p>￼</p>

<p>假设两种场景：</p>

<p>场景一：顺序操作     <br />
初始化条件：商品A有1个库存</p>
<ul>
  <li>订单服务第一次请求库存服务，查询商品还有库存，要求对商品A减少1个库存，库存DB执行 <code class="language-plaintext highlighter-rouge">update goods_stock quantity = quantity - 1 where goods_id = A</code> 之后，quantity 字段为0，下单成功</li>
  <li>订单服务第二次请求库存服务，查询商品没有库存，则下单失败</li>
</ul>

<p>场景二：并发操作      <br />
初始化条件：商品A有1个库存</p>
<ul>
  <li>订单第一次扣库存请求和第二次扣库存请求，都同时到了 库存服务，查询都有库存，都进行 <code class="language-plaintext highlighter-rouge">update goods_stock quantity = quantity - 1 where goods_id = A</code> 之后，quantity 字段为-1，两次下单都成功</li>
</ul>

<p>场景二会导致多卖一件，即发生超卖</p>

<p>发生超卖的原因：查询拦截 和 扣减库存 是两个割裂开的动作，并非一个原子操作， 解决办法，也比较简单， 将查询拦截 和 扣减库存 两个动作 做成原子的，有很多办法</p>

<h4 id="heading-小并发防超卖">小并发防超卖</h4>

<p>如果并发比较小（扣库存操作的OPS &lt; 库存DB能够承担的 OPS）最简单的可能是利用sql对数据的影响条数来判断</p>

<p>可用sql：<code class="language-plaintext highlighter-rouge">update goods_stock quantity = quantity - 1 where goods_id = A and quantity &gt;0</code>       <br />
判断依据：影响行数 &gt;0 则说明扣减成功，影响行数 &lt;=0 则说明扣减失败，拦截订单</p>

<h4 id="heading-大并发防超卖">大并发防超卖</h4>

<p>如果并发比较大（扣库存操作的OPS &gt; 库存DB能够承担的 OPS），单用 DB 做原子操作，对DB的压力比较大，所以要想个办法，既能让 库存判断 和 库存扣减 组成一个原子操作，又能承受很高的OPS。</p>

<p>最先想到的就是用Redis来代替DB支持高OPS。但是用Redis就需要考虑如下几个场景：</p>

<ul>
  <li>DB 和 Redis 数据同步（什么时候将DB数据同步到Redis， 什么时候将Redis数据同步DB）</li>
  <li>查询拦截 和 扣减库存 两个操作，如何用Redis做成原子化？</li>
</ul>

<p>Redis在高并发场景下的使用姿势基本是固定的，先不考虑 更新DB 和 更新Redis 失败的情况，在保证 更新DB 和 更新Redis 这两个操作都能成功的情况下，更新Redis的 Design Pattern有四种：</p>

<ul>
  <li>Cache Aside</li>
  <li>Read Through</li>
  <li>Write Through</li>
  <li>Write Behind Caching</li>
</ul>

<p>简单说下四种模式的区别：</p>

<p>Cache aside，查询：应用程序从cache中取数据，取到后返回； 没有得到，则从数据库中取数据，成功后，放到缓存中。跟新：先把数据存到数据库中，成功后，再让缓存失效。</p>

<p>Read Through Pattern， 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>

<p>Write Through Pattern，套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）</p>

<p>Write Behind Caching 在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比（因为直接操作内存嘛 ），因为异步，write backg还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。</p>

<blockquote>
  <p>再说明一点：所有 Redis 跟新 Desing Pattern 都是会有问题的，在软件设计上，我们基本上不可能做出一个没有缺陷的设计，软件设计从来都是取舍</p>
</blockquote>

<p>根据上面四种模式，基本能看出， Write Behind Caching 是我们需要的模式，在请求中，只更新缓存，异步更新数据库，至于异步的逻辑，也有提到（可以是单条处理，可以是批处理）</p>

<p>那有个问题，由于库存以redis为准，何时初始化redis数据？redis过期时间怎么处理？ 是否全部都以Redis为准？</p>

<p>先思考个问题，是所有商品都会有大并发的扣库存操作（爆品）？还是部分商品是爆品？成为爆品是否可预测 ？</p>

<p>在我了解的电商场景里面，这个几个问题的答案是：不是所有的商品都是爆品，爆品可预测。 经验来看，仅秒杀场景（定时开售，高性价比）商品所产生的库存扣减流量，才会导致DB承受不住扣减库存OPS。</p>

<p>￼
<img src="http://int32-blog.oss-cn-beijing.aliyuncs.com/Pasted%20Graphic.png" alt="image" /></p>

<p>上图是整个操作流程，看图再回答下上面的问题：</p>

<ul>
  <li>何时初始化redis数据？ 在创建商品的时候，可把数据设置进去</li>
  <li>redis过期时间怎么处理？ 随着商品被删除、售罄 等动作删除，也可以用job来做数据兜底，比如check删除的商品，缓存是否都被删除了</li>
  <li>是否全部都以Redis为准？ 爆款商品以redis为准，普通商品以DB为准（扣库存DB是正规操作，为了维稳，只能针对爆款（少数）商品 以Redis为准</li>
</ul>

<p>再说下这个问题：查询拦截 和 扣减库存 两个操作，如何用Redis做成原子化？</p>

<p>Redis对命令是原子化的（因为对命令处理是单线程的），所以使用lua脚本把 查询拦截 和 扣减库存 做成一个命令，保证原子化。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StockService</span> <span class="o">{</span>

    <span class="cm">/**
     * Redis 客户端
     */</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">RedisTemplate</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">redisTemplate</span><span class="o">;</span>

    <span class="cm">/**
     * 执行扣库存的脚本
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">STOCK_LUA</span><span class="o">;</span>

    <span class="kd">static</span> <span class="o">{</span>
        <span class="cm">/**
         *
         * @desc 扣减库存Lua脚本
         * 库存（stock）0：表示扣库存失败，没有可用库存
         * 库存（stock）1：表示扣库存成功
         */</span>
        <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"if (redis.call('exists', KEYS[1]) == 1) then"</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"    local stock = tonumber(redis.call('get', KEYS[1]));"</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"    local num = tonumber(ARGV[1]);"</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"    if (stock &gt;= num) then"</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"        redis.call('incrby', KEYS[1], 0 - num);"</span><span class="o">);</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"        return 1;
        sb.append("</span>    <span class="n">end</span><span class="o">;</span><span class="s">");
        sb.append("</span>    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span><span class="s">");
        sb.append("</span><span class="n">end</span><span class="o">;</span><span class="s">");
        sb.append("</span><span class="k">return</span> <span class="mi">0</span><span class="o">;</span><span class="err">"</span><span class="o">);</span>
        <span class="no">STOCK_LUA</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 扣库存
     *
     * @param key 库存key
     * @param num 扣减库存数量
     * @return true 扣成功；false 扣失败
     */</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">decrStock</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span><span class="o">,</span> <span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 脚本里的KEYS参数</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">keys</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="c1">// 脚本里的ARGV参数</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">args</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">args</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>

        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">redisTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">RedisCallback</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="nc">Long</span> <span class="nf">doInRedis</span><span class="o">(</span><span class="nc">RedisConnection</span> <span class="n">connection</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">DataAccessException</span> <span class="o">{</span>
                <span class="nc">Object</span> <span class="n">nativeConnection</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">getNativeConnection</span><span class="o">();</span>
                <span class="c1">// 集群模式和单机模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行</span>
                <span class="c1">// 集群模式</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">nativeConnection</span> <span class="k">instanceof</span> <span class="nc">JedisCluster</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="o">(</span><span class="nc">Long</span><span class="o">)</span> <span class="o">((</span><span class="nc">JedisCluster</span><span class="o">)</span> <span class="n">nativeConnection</span><span class="o">).</span><span class="na">eval</span><span class="o">(</span><span class="no">STOCK_LUA</span><span class="o">,</span> <span class="n">keys</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// 单机模式</span>
                <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nativeConnection</span> <span class="k">instanceof</span> <span class="nc">Jedis</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="o">(</span><span class="nc">Long</span><span class="o">)</span> <span class="o">((</span><span class="nc">Jedis</span><span class="o">)</span> <span class="n">nativeConnection</span><span class="o">).</span><span class="na">eval</span><span class="o">(</span><span class="no">STOCK_LUA</span><span class="o">,</span> <span class="n">keys</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>

        <span class="k">return</span> <span class="n">result</span> <span class="o">==</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<h2 id="heading-总结">总结</h2>

<ul>
  <li>超卖分为 业务导致超卖 和 技术导致超卖</li>
  <li>只要业务流程正规，则不会导致业务超卖</li>
  <li>只要保证 查询拦截 和 扣减库存 两个操作能被一个原子操作包裹，则不会导致技术超卖</li>
  <li>保证 查询拦截 和 扣减库存 两个操作能被一个原子操作包裹， 在大并发 和 小并发 场景，分别有不同的实现方案</li>
</ul>

<blockquote>
  <p>上述均个人观点，欢迎拍砖，有问题可 留言/邮件 讨论。</p>
</blockquote>
:ET