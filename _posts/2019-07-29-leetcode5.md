---
layout: post
title: "LeetCode 16 94 95 96 98"
description: "一切又重新开始，像第一次那样"
categories: [LeetCode]
tags: [algorithm]
---

* Kramdown table of contents
{:toc .toc}

# 16 最接近的三数之和 

```golang
func threeSumClosest(nums []int, target int) int {
	minDiscount := math.MaxInt64
	result := target
	for i := 0; i < len(nums); i++ {
		for j := 0; j < len(nums); j++ {
			if j == i {
				continue
			}

			for k := 0; k < len(nums); k++ {
				if k == i || k == j {
					continue
				}

				discount := int(math.Abs(float64(nums[i] + nums[j] + nums[k] - target)))
				if discount < minDiscount {
					minDiscount = discount
					result = nums[i] + nums[j] + nums[k]
				}
			}
		}
	}

	return result
}

```

> 暴力也通过了

# 17. 电话号码的字母组合

```java
class Solution {
    
    
    public List<String> letterCombinations(String digits) {
        
        if(digits.length()==0||digits==null) return new ArrayList<String>();
        
        Map<Integer,String> map = new HashMap<>();
        map.put(2,"abc");
        map.put(3,"def");
        map.put(4,"ghi");
        map.put(5,"jkl");
        map.put(6,"mno");
        map.put(7,"pqrs");
        map.put(8,"tuv");
        map.put(9,"wxyz");
        return letterCombinations(digits,map);
    }
    
    
    public List<String> letterCombinations(String digits,Map<Integer,String> map){
        List<String> now = new ArrayList<>();
        
        if(digits.length() == 1){
            String s = map.get(Integer.parseInt(digits));
            for(int i=0;i<s.length();i++){
                now.add(""+s.charAt(i));
            }
            return now;
        }
        
        List<String> pre = letterCombinations(digits.substring(1),map);
        String head = map.get(Integer.parseInt(digits.substring(0,1)));
        
        
        for(String s : pre){
           for(int j=0;j<head.length();j++){
               now.add(head.charAt(j)+s);
           }
            
        }
        return now;
    }
}
```

# 二叉树的中序遍历

```golang
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func inorderTraversal(root *TreeNode) []int {
	result := make([]int, 0)
	if root == nil {
		return result
	}

	result = append(result, inorderTraversal(root.Left)...)
	result = append(result, (*root).Val)
	result = append(result, inorderTraversal(root.Right)...)

	return result
}
```

# 不同的二叉搜索树II

```golang

func generateTreesMore(points []int) []*TreeNode {
	result := make([]*TreeNode, 0)
	if len(points) == 1 {
		result = append(result, &TreeNode{points[0], nil, nil})
		return result
	}

	if len(points) == 0 {
		return result
	}

	for i, _ := range points {
		leftTrees := generateTreesMore(points[:i])
		rightTrees := generateTreesMore(points[i+1:])

		if len(leftTrees) == 0 {
			for _, v := range rightTrees {
				result = append(result, &TreeNode{points[i], nil, v})
			}
		} else if len(rightTrees) == 0 {
			for _, v := range leftTrees {
				result = append(result, &TreeNode{points[i], v, nil})
			}
		} else {
			for _, l := range leftTrees {
				for _, r := range rightTrees {
					result = append(result, &TreeNode{points[i], l, r})
				}
			}
		}
	}

	return result
}

func generateTrees(n int) []*TreeNode {
	points := make([]int, 0)
	for i := 1; i <= n; i++ {
		points = append(points, i)
	}

	return generateTreesMore(points)
}

```
> 自己A的，牛逼的不得了

# 不同的二叉搜索树

```golang

func generateTreesMoreNum(points []int) int {
	if len(points) == 1 {
		return 1
	}

	if len(points) == 0 {
		return 0
	}

	result := 0
	for i, _ := range points {
		leftResult := generateTreesMoreNum(points[:i])
		rightResult := generateTreesMoreNum(points[i+1:])

		if leftResult == 0 {
			result += rightResult
		} else if rightResult == 0 {
			result += leftResult
		} else {
			result += leftResult * rightResult
		}
	}

	return result
}

func numTrees(n int) int {
	points := make([]int, 0)
	for i := 1; i <= n; i++ {
		points = append(points, i)
	}

	return generateTreesMoreNum(points)
}
```

# 98 验证二叉搜索树

```golang


func midShow(root *TreeNode) []int {
	if root == nil {
		return make([]int, 0)
	}

	result := make([]int, 0)
	result = append(result, midShow(root.Left)...)
	result = append(result, root.Val)
	result = append(result, midShow(root.Right)...)

	return result
}

func isValidBST(root *TreeNode) bool {
	l := midShow(root)
	if len(l) == 0 {
		return true
	}

	min := l[0]
	for _, v := range l[1:] {
		if v <= min {
			return false
		}
		min = v
	}

	return true
}

```


